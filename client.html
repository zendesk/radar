<!DOCTYPE html>
<html>
  <head>
    <title>radar - High level API and backend for writing web apps that use push messaging</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" href="assets/css/style.css">
    <link type="text/css" rel="stylesheet" href="assets/css/prettify.css"/>

    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript" src="assets/js/prettify.js"></script>

  </head>
<body onload="prettyPrint()">

  <div id="toc">
    <div id="toc-inner">
      <h4>Table of contents</h4>

      <h5><a href="index.html">Overview &amp; tutorial</a></h5>

      <h5><a href="client.html">Radar client</a></h5>

      <h5><a href="server.html">Radar server</a></h5>

      <h5><a href="rest.html">REST API</a></h5>

      <h5><a href="https://github.com/zendesk/radar" target="_blank">Full source code on Github</a></h5>

      <h5><a href="http://www.zendesk.com/company/careers?jvi=oHiWWfwB,Job" target="_blank">Zendesk is hiring Radar developers</a></h5>

    </div>
  </div>

  <div id="wrapper">
    <div id="header">

    </div>

    <div class="clear"></div>
    <div id="main">
      <div id="content" class="post">


      <h1>Radar client</h1>

      <h2>Basic usage</h2>

<pre class="prettyprint"><code>RadarClient.configure({ ... }).alloc('example', function (){
  RadarClient.status("invite/1234")
    .on(function(msg) { console.log(msg) })
    .sync();
}).connect();
</code></pre>

      <p>"example" is an arbitrary name for your functionality, which is used to determine whether to keep the connection alive or not.</p>
      <p>API calls - see the <a href="rest.html">REST API docs</a> for more details:</p>

<pre><code>curl -k -H "Content-Type: application/json" -X POST -d '
{
  "op":"set",
  "to":"status:/test/invite/1234",
  "key":"greeting",
  "value":"hello"
}
' https://localhost:8000/api
</code></pre>

      <h2>Configuration</h2>
      <p>The backend URL needs to be configured before using RadarClient.</p>

<pre class="prettyprint"><code>RadarClient.configure({
  host: 'localhost',
  port: 8000,
  secure: false,
  userId: 1,
  userType: 2,
  accountName: 'test'
});
</code></pre>

      <p>The configuration object is passed to the underlying <a href="https://github.com/LearnBoost/engine.io-client">engine.io-client</a>.</p>
      <h2>Connecting via .alloc() / .dealloc()</h2>
      <p>
        The .alloc() and .dealloc() connection API allows multiple independent parts
        of a web app to use a single persistent connection. This way the Radar client
        can tell when no-one is using the connection. If a direct connect()/disconnect()
        API was used, inpendent parts of the app could accidentally disconnect even when
        the connection is still used elsewhere.
      </p>
      <ul class="list">
        <li>
          <p><code>.alloc(name, callback)</code></p>
          <ul class="list">
            <li>
              Ensures that a connection is established, then calls the callback. If the connection is not established,
              then the call is delayed until connected.
            </li>
            <li>The name can be any string unique to the functionality (e.g. chat, voice etc.)</li>
          </ul>
        </li>
        <li>
          <p><code>.dealloc(name)</code></p>
          <ul class="list">
            <li>Indicates that the connection is no longer needed by the named functionality.</li>
            <li>When no-one needs the connection, issues a disconnect.</li>
          </ul>
        </li>
      </ul>

      <p>Unlike a simple counter, alloc() and dealloc() can be safely called multiple times.</p>

      <h2>Accessing resources</h2>

      <p>The Radar client API is resource-based. Resources have a type and a name, and support different operations.</p>
      <ul class="list">
        <li>
          <code>RadarClient.presence(name)</code>: "whether a user is online and marked as present on this resource".
          Presence is tied to the user ID.
        </li>
        <li>
          <code>RadarClient.status(name)</code>: "a hash with subkeys you can subscribe to, such as when a post was last updated".
          Status resources exist so that your can receive notifications about a single value changing, for example, when your web
          backend updates a value.
        </li>
        <li>
          <code>RadarClient.message(name)</code>: "a ordered stream of messages". Message lists are like chat message streams.
          They contain messages, and can be configured to store those messages so that new participants can fetch the full history
          of messages. In the event of a connection loss, any messages sent while disconnected are sent when the connection is
          re-established.
        </li>
      </ul>

      <p>Each of these returns a chainable object specific to that resource + name.</p>
      <p>For example:</p>
<pre class="prettyprint"><code>RadarClient.presence(name).on(function(message) {
  console.log(message);
}).set('online').sync();
</code></pre>

      <h2>Message handlers</h2>
      <p>All resources accept message handlers. Message handlers are triggered when a message relevant to the resource is received. You have three choices:</p>
      <ul class="list">
        <li>
          <code>.on(callback)</code>: attach a handler permanently until explicitly removed
        </li>
        <li>
          <code>.once(callback)</code>: attach a handler that is removed after it is triggered once
        </li>
        <li>
          <code>.when(callback)</code>: attach a handler that is only removed if the return value from the
          handler is true. Useful for waiting for a specific message.
        </li>
      </ul>

      <p>Callbacks accept one argument, which is the message returned from the backend.</p>

      <h2>Operations</h2>

      <p>Each resource type has its own set of operations.</p>

      <h3>Operation acknowledgements</h3>

      <p>
        Many functions take an optional [ack] callback function argument as their last parameter.
        If the ack callback is specified, the client requests an acknowledgement (ACK) from the server,
        and runs the callback when the ACK is received. This is useful for tests and when you want to be
        sure that an operation has completed before going to the next one.
      </p>

      <h2>Presence resources</h2>

      <p>
        These are binary (e.g. online and offline). Presence is tied to the user id, and it can be set to
        "offline" either explicitly, or if the user's TCP connection is lost (there is a grace period up to 30 seconds).
      </p>

      <h3>Presence API methods .presence("scope").*</h3>

      <ul class="list">
        <li>
          <code>.set('online', [ack])</code> / <code>.set('offline', [ack])</code>
          <ul class="list">
            <li>Sets presence</li>
          </ul>
        </li>
        <li>
          <p><code>.get(callback)</code></p>
          <ul class="list">
            <li>Immediately retrieves the presence resource content and returns it.</li>
            <li>
              <p>callback(message): message is a JSON object, which looks like this:</p>
<pre class="prettyprint"><code>{
  "op": "get",
  "to": "presence:/account/scope",
  "value": {
    "123": {
      "userType": 0,
      "clients": {
        "asdfghjk": {}
      }
    }
  }
}
</code></pre>
            </li>
          </ul>

          <p>
            Here, 123 is the user ID and the userType is the value that was provided by the client configuration. "clients" are 
          </p>

          <p>If the user is offline, they will not be included in the result.</p>

        </li>
        <li>
          <code>.subscribe([ack])</code>
          <ul class="list">
            <li>
              Subscribes to notifications on the current presence resource (which includes the current user and other
              users that act on that presence resource)
            </li>
          </ul>
        </li>
        <li>
          <code>.unsubscribe([ack])</code>
          <ul class="list">
            <li>Removes a subscription</li>
          </ul>
        </li>
      </ul>

      <h2>Status resources</h2>

      <p>Push notifications about changes to a variable.</p>
      <p>
        Status resources can have multiple values (e.g. browser, phone, unavailable). Status is per-user, but it never
        expires by itself and is not tied to user presence.
      </p>

      <h3>Status API methods .status("scope").*</h3>

      <ul class="list">
        <li>
          <code>.set('foo', [ack])</code>
          <ul class="list">
            <li>Sets status</li>
          </ul>
        </li>
        <li>
          <p><code>.get(callback)</code></p>
          <ul class="list">
            <li>Immediately retrieves the status resource content and returns it.</li>
            <li><p>callback(message): message is a JSON object, which looks like this:</p>
            <p>{
              "op": "get"
              "value": { "123": "foo" }
            }</p>
            </li>
          </ul>

          <p>Here, 123 is the user ID, and "foo" is the value set by calling status('abc').set('foo');</p>
          <p>You can set the value to an arbitrary JSON object: <code>.status('voice/status').set({ hello: "world" });</code></p>
        </li>
        <li>
          <code>.subscribe([ack])</code>
          <ul class="list">
            <li>Subscribes to notifications</li>
          </ul>
        </li>
        <li>
          <code>.unsubscribe([ack])</code>
          <ul class="list">
            <li>Removes a subscription</li>
          </ul>
        </li>
      </ul>

      <h2>Message list resources</h2>

      <p>Message streams about a topic.</p>
      <p>
        Message lists contain ordered information that can be appended to, and can be synchronized. In the event of a
        connection loss, any messages sent while disconnected are sent when the connection is re-established.
      </p>

      <h3>Message list API methods</h3>

      <p>Note: the API here conforms to the Drone API so that we can transition from Drone to Radar_client fairly easily.</p>

      <ul class="list">
        <li><code>.subscribe('channel')</code></li>
        <li><code>.unsubscribe('channel')</code></li>
        <li><code>.sync('channel')</code></li>
        <li><code>.publish('channel', message)</code></li>
      </ul>

      <p>
        By default, message list resources are not persistent - e.g. messages will be sent to subscribers, but the message
        history is not accessible. You can configure message persistence on a per-resource-type basis in the server - see the
        server configuration for details.
      </p>

      <h2>Client states</h2>

      <p>There are a few states that the client UI should handle gracefully:</p>

      <ul class="list">
        <li>
          "connected" AKA "ready": This should be a once() callback, and set up the basic UI.
        </li>
        <li>
          "disconnected": If this state occurs, then the UI should be set in a state that 1) makes it clear that communication
          is currently not possible and 2) allows the user to perform a reconnection. For example, gray out all users in a chat
          and show a yellow notification stating "reconnecting".
        </li>
        <li>
          "reconnecting": the notification should change to show that a reconnection is in progress or is pending:
          reconnecting(in_seconds) events should occur.
        </li>
        <li>"reconnected": the notification should change to show that the user is now connected again.</li>
        <li>"unavailable": If this state occurs, then the UI should show a message that the connection could not be established.</li>
      </ul>



      </div>
    </div>

    <div class="clear">
    </div>

    <div id="footer">
    </div>
  </div>
</body>
</html>
