{
  "name": "engine.io",
  "version": "0.2.2",
  "description": "The realtime engine behind Socket.IO. Provides the foundation of a bidirectional connection between client and server",
  "main": "./lib/engine.io",
  "author": {
    "name": "Guillermo Rauch",
    "email": "guillermo@learnboost.com"
  },
  "contributors": [
    {
      "name": "Eugen Dueck",
      "url": "https://github.com/EugenDueck"
    }
  ],
  "dependencies": {
    "debug": "0.6.0",
    "engine.io-client": "0.2.2",
    "ws": "~0.4.21"
  },
  "devDependencies": {
    "mocha": "*",
    "expect.js": "*",
    "superagent": "*",
    "ws": "*",
    "s": "*"
  },
  "scripts": {
    "test": "make test"
  },
  "readme": "# Engine.IO: the realtime engine\n\n[![Build Status](https://secure.travis-ci.org/LearnBoost/engine.io.png)](http://travis-ci.org/LearnBoost/engine.io)\n\n`Engine` is the implementation of transport-based cross-browser/cross-device\nbi-directional communication layer for\n[Socket.IO](http://github.com/learnboost/socket.io).\n\n## Hello World\n\n### Server\n\n#### (A) Listening on a port\n\n```js\nvar engine = require('engine.io')\n  , server = engine.listen(80)\n\nserver.on('connection', function (socket) {\n  socket.send('utf 8 string');\n});\n```\n\n#### (B) Intercepting requests for a http.Server\n\n```js\nvar engine = require('engine.io')\n  , http = require('http').createServer().listen(3000)\n  , server = engine.attach(http)\n\nserver.on('connection', function (socket) {\n  socket.on('message', function () { });\n  socket.on('close', function () { });\n});\n```\n\n#### (C) Passing in requests\n\n```js\nvar engine = require('engine.io')\n  , server = new engine.Server()\n\nserver.on('connection', function (socket) {\n  socket.send('hi');\n});\n\n// â€¦\nhttpServer.on('upgrade', function (req, socket, head) {\n  server.handleUpgrade(req, socket, head);\n});\nhttpServer.on('request', function (req, res) {\n  server.handleRequest(req, res);\n});\n```\n\n### Client\n\n```html\n<script src=\"/path/to/engine.io.js\"></script>\n<script>\n  var socket = new eio.Socket({ host: 'localhost', port: 80 });\n  socket.on('open', function () {\n    socket.on('message', function (data) { });\n    socket.on('close', function () { });\n  });\n</script>\n```\n\nFor more information on the client refer to the\n[engine-client](http://github.com/learnboost/engine.io-client) repository.\n\n## What features does it have?\n\n- **Isomorphic with WebSocket.IO**. You can switch between a WebSocket server\n  and a multi-transport server by chaning the `require`.\n- **Maximum reliability**. Connections are established even in the presence of:\n  - proxies and load balancers.\n  - personal firewall and antivirus software.\n  - for more information refer to **Goals** and **Architecture** sections\n- **Minimal client size** aided by:\n  - lazy loading of flash transports.\n  - lack of redundant transports.\n- **Scalable**\n  - load balancer friendly\n- **Future proof**\n- **100% Node.JS core style**\n  - No API sugar (left for higher level projects)\n  - Written in readable vanilla JavaScript\n\n## API\n\n### Server\n\n<hr><br>\n\n#### Top-level\n\nThese are exposed by `require('engine.io')`:\n\n##### Events\n\n- `flush`\n    - Called when a socket buffer is being flushed.\n    - **Arguments**\n      - `Socket`: socket being flushed\n      - `Array`: write buffer\n- `drain`\n    - Called when a socket buffer is drained\n    - **Arguments**\n      - `Socket`: socket being flushed\n\n##### Properties\n\n- `protocol` _(Number)_: protocol revision number\n- `Server`: Server class constructor\n- `Socket`: Socket class constructor\n- `Transport` _(Function)_: transport constructor\n- `transports` _(Object)_: map of available transports\n\n##### Methods\n\n- `listen`\n    - Creates an `http.Server` which listens on the given port and attaches WS\n      to it. It returns `501 Not Implemented` for regular http requests.\n    - **Parameters**\n      - `Number`: port to listen on.\n      - `Function`: callback for `listen`.\n    - **Returns** `Server`\n- `attach`\n    - Captures `upgrade` requests for a `http.Server`. In other words, makes\n      a regular http.Server websocket-compatible.\n    - **Parameters**\n      - `http.Server`: server to attach to.\n      - `Object`: optional, options object\n    - **Options**\n      - `path` (`String`) default prefix path (`/engine.io`)\n      - `resource` (`String`): name of resource for this server (`default`).\n        Setting a resource allows you to initialize multiple engine.io\n        endpoints on the same host without them interfering, and without\n        changing the `path` directly.\n      - `policyFile` (`Boolean`): whether to handle policy file requests (`true`)\n      - `destroyUpgrade` (`Boolean`): destroy unhandled upgrade requests (`true`)\n      - **See Server options below for additional options you can pass**\n    - **Returns** `Server`\n\n<hr><br>\n\n#### Server\n\nThe main server/manager. _Inherits from EventEmitter_.\n\n##### Events\n\n- `connection`\n    - Fired when a new connection is established.\n    - **Arguments**\n      - `Socket`: a Socket object\n\n##### Properties\n\n**Important**: if you plan to use engine.io in a scalable way, please\nkeep in mind the properties below will only reflect the clients connected\nto a single process.\n\n- `clients` _(Object)_: hash of connected clients by id.\n- `clientsCount` _(Number)_: number of connected clients.\n\n##### Methods\n\n- **constructor**\n    - Initializes the server\n    - **Parameters**\n      - `Object`: optional, options object\n    - **Options**\n      - `pingTimeout` (`Number`): how many ms without a pong packet to\n        consider the connection closed (`60000`)\n      - `pingInterval` (`Number`): how many ms before sending a new ping\n        packet (`25000`)\n      - `transports` (`<Array> String`): transports to allow connections\n        to (`['polling', 'websocket', 'flashsocket']`)\n      - `allowUpgrades` (`Boolean`): whether to allow tranport upgrades\n        (`true`)\n      - `cookie` (`String|Boolean`): name of the HTTP cookie that\n        contains the client sid to send as part of handshake response\n        headers. Set to `false` to not send one. (`io`)\n- `close`\n    - Closes all clients\n    - **Returns** `Server` for chaining\n- `handleRequest`\n    - Called internally when a `Engine` request is intercepted.\n    - **Parameters**\n      - `http.ServerRequest`: a node request object\n      - `http.ServerResponse`: a node response object\n    - **Returns** `Server` for chaining\n- `handleUpgrade`\n    - Called internally when a `Engine` ws upgrade is intercepted.\n    - **Parameters** (same as `upgrade` event)\n      - `http.ServerRequest`: a node request object\n      - `net.Stream`: TCP socket for the request\n      - `Buffer`: legacy tail bytes\n    - **Returns** `Server` for chaining\n- `handleSocket`\n    - Called with raw TCP sockets from http requests to intercept flash policy\n      file requests\n    - **Parameters**\n      - `net.Stream`: TCP socket on which requests are listened\n    - **Returns** `Server` for chaining\n\n<hr><br>\n\n#### Socket\n\nA representation of a client. _Inherits from EventEmitter_.\n\n##### Events\n\n- `close`\n    - Fired when the client is disconnected.\n    - **Arguments**\n      - `String`: reason for closing\n      - `Object`: description object (optional)\n- `message`\n    - Fired when the client sends a message.\n    - **Arguments**\n      - `String`: unicode string\n- `error`\n    - Fired when an error occurs.\n    - **Arguments**\n      - `Error`: error object\n- `flush`\n    - Called when the write buffer is being flushed.\n    - **Arguments**\n      - `Array`: write buffer\n- `drain`\n    - Called when the write buffer is drained\n\n##### Properties\n\n- `server` _(Server)_: engine parent reference\n- `request` _(http.ServerRequest)_: request that originated the Socket\n- `upgraded` _(Boolean)_: whether the transport has been upgraded\n- `readyState` _(String)_: opening|open|closing|closed\n- `transport` _(Transport)_: transport reference\n\n##### Methods\n\n- `send`:\n    - Sends a message, performing `message = toString(arguments[0])`.\n    - **Parameters**\n      - `String`: a string or any object implementing `toString()`, with outgoing data\n    - **Returns** `Socket` for chaining\n- `close`\n    - Disconnects the client\n    - **Returns** `Socket` for chaining\n\n### Client\n\n<hr><br>\n\nExposed in the `eio` global namespace (in the browser), or by\n`require('engine.io-client')` (in Node.JS).\n\nFor the client API refer to the \n[engine-client](http://github.com/learnboost/engine-client) repository.\n\n## Transports\n\n- `polling`: XHR / JSONP polling transport.\n- `websocket`: WebSocket transport.\n- `flashsocket`: WebSocket transport backed by flash.\n\n## Plugins\n\n- [engine.io-conflation](https://github.com/EugenDueck/engine.io-conflation): Makes **conflation and aggregation** of messages straightforward.\n\n## Support\n\nThe support channels for `engine.io` are the same as `socket.io`:\n  - irc.freenode.net **#socket.io**\n  - [Google Groups](http://groups.google.com/group/socket_io)\n  - [Website](http://socket.io)\n\n## Development\n\nTo contribute patches, run tests or benchmarks, make sure to clone the\nrepository:\n\n```\ngit clone git://github.com/LearnBoost/engine.io.git\n```\n\nThen:\n\n```\ncd engine.io\nnpm install\n```\n\n## Tests\n\n### Unit/Integration\n\n```\n$ make test\n```\n\n### Acceptance\n\n```\n# make test-acceptance\n```\n\nAnd point browser/s to `http://localhost:3000`.\n\n### Server\n\n## Benchmarks\n\n### Server\n\n```\n$ make bench\n```\n\n### Client\n\n```\n$ make bench-server\n```\n\nAnd point browser/s to `http://localhost:3000`.\n\n## Goals\n\nThe main goal of `Engine` is ensuring the most reliable realtime communication.\nUnlike the previous socket.io core, it always establishes a long-polling\nconnection first, then tries to upgrade to better transports that are \"tested\" on\nthe side.\n\nDuring the lifetime of the socket.io projects, we've found countless drawbacks\nto relying on `HTML5 WebSocket` or `Flash Socket` as the first connection\nmechanisms.\n\nBoth are clearly the _right way_ of establishing a bidirectional communication,\nwith HTML5 WebSocket being the way of the future. However, to answer most business\nneeds, alternative traditional HTTP 1.1 mechanisms are just as good as delivering\nthe same solution.\n\nWebSocket/FlashSocket based connections have two fundamental benefits:\n\n1. **Better server performance**\n\n  - _A: Load balancers_<br>\n      Load balancing a long polling connection poses a serious architectural nightmare\n      since requests can come from any number of open sockets by the user agent, but\n      they all need to be routed to the process and computer that owns the `Engine`\n      connection. This negatively impacts RAM and CPU usage.\n  - _B: Network traffic_<br>\n      WebSocket is designed around the premise that each message frame has to be \n      surrounded by the least amount of data. In HTTP 1.1 transports, each message\n      frame is surrounded by HTTP headers and chunked encoding frames. If you try to\n      send the message _\"Hello world\"_ with xhr-polling, the message ultimately\n      becomes larger than if you were to send it with WebSocket.\n  - _C: Lightweight parser_<br>\n      As an effect of **B**, the server has to do a lot more work to parse the network\n      data and figure out the message when traditional HTTP requests are used\n      (as in long polling). This means that another advantage of WebSocket is\n      less server CPU usage.\n\n2. **Better user experience**\n\n    Due to the reasons stated in point **1**, the most important effect of being able\n    to establish a WebSocket connection is raw data transfer speed, which translates\n    in _some_ cases in better user experience.\n\n    Applications with heavy realtime interaction (such as games) will benefit greatly,\n    whereas applications like realtime chat (Gmail/Facebook), newsfeeds (Facebook) or\n    timelines (Twitter) will have negligible user experience improvements.\n\nHaving said this, attempting to establish a WebSocket connection directly so far has\nproven problematic:\n\n1. **Proxies**<br>\n    Many corporate proxies block WebSocket traffic.\n\n2. **Personal firewall and antivirus software**<br>\n    As a result of our research, we've found that at least 3 personal security\n    applications block websocket traffic.\n\n3. **Cloud application platforms**<br>\n    Platforms like Heroku or No.de have had trouble keeping up with the fast-paced\n    nature of the evolution of the WebSocket protocol. Applications therefore end up\n    inevitably using long polling, but the seamless installation experience of \n    socket.io we strive for (_\"require() it and it just works\"_) disappears.\n\nSome of these problems have solutions. In the case of proxies and personal programs,\nhowever, the solutions many times involve upgrading software. Experience has shown\nthat relying on client software upgrades to deliver a business solution is\nfruitless: the very existence of this project has to do with a fragmented panorama\nof user agent distribution, with clients connecting with latest versions of the most\nmodern user agents (Chrome, Firefox and Safari), but others with versions as low as\nIE 5.5.\n\nFrom the user perspective, an unsuccessful WebSocket connection can translate in\nup to at least 10 seconds of waiting for the realtime application to begin\nexchanging data. This **perceptively** hurts user experience.\n\nTo summarize, **Engine** focuses on reliability and user experience first, marginal\npotential UX improvements and increased server performance second. `Engine` is the\nresult of all the lessons learned with WebSocket in the wild.\n\n## Architecture\n\nThe main premise of `Engine`, and the core of its existence, is the ability to\nswap transports on the fly. A connection starts as xhr-polling, but it can\nswitch to WebSocket.\n\nThe central problem this poses is: how do we switch transports without losing\nmessages?\n\n`Engine` only switches from polling to another transport in between polling\ncycles. Since the server closes the connection after a certain timeout when\nthere's no activity, and the polling transport implementation buffers messages\nin between connections, this ensures no message loss and optimal performance.\n\nAnother benefit of this design is that we workaround almost all the limitations\nof **Flash Socket**, such as slow connection times, increased file size (we can\nsafely lazy load it without hurting user experience), etc.\n\n## FAQ\n\n### Can I use engine without Socket.IO ?\n\nAbsolutely. Although the recommended framework for building realtime applications\nis Socket.IO, since it provides fundamental features for real-world applications \nsuch as multiplexing, reconnection support, etc.\n\n`Engine` is to Socket.IO what Connect is to Express. An essential piece for building\nrealtime frameworks, but something you _probably_ won't be using for building\nactual applications.\n\n### Does the server serve the client?\n\nNo. The main reason is that `Engine` is meant to be bundled with frameworks.\nSocket.IO includes `Engine`, therefore serving two clients is not necessary. If\nyou use Socket.IO, including\n\n```html\n<script src=\"/socket.io/socket.io.js\">\n```\n\nhas you covered.\n\n### Can I implement `Engine` in other languages?\n\nAbsolutely. The [SPEC](https://github.com/LearnBoost/engine.io-client/blob/master/SPEC.md)\nfile contains the most up to date description of the implementation specification\nat all times. If you're targeting the latest stable release of `Engine`, make sure\nto look at the file in the appropriate git branch/tag.\n\nThe Java/NIO implementation will be officially supported, and is being worked\non by the author.\n\n## License \n\n(The MIT License)\n\nCopyright (c) 2011 Guillermo Rauch &lt;guillermo@learnboost.com&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "_id": "engine.io@0.2.2",
  "_from": "engine.io@0.2.2",
  "dist": {
    "shasum": "ee2e56937d1995d9a77991ee995ea85df33e02eb"
  },
  "_resolved": "https://registry.npmjs.org/engine.io/-/engine.io-0.2.2.tgz"
}
