{
  "name": "minilog",
  "description": "Lightweight client & server-side logging with Stream-API backends and counting, timing support",
  "version": "0.1.0",
  "main": "lib/index.js",
  "dependencies": {},
  "devDependencies": {
    "mocha": "*",
    "gluejs": "git://github.com/mixu/gluejs.git"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/mixu/minilog.git"
  },
  "author": {
    "name": "Mikito Takada",
    "email": "mikito.takada@gmail.com",
    "url": "http://blog.mixu.net/"
  },
  "keywords": [
    "logging",
    "sysadmin",
    "tools"
  ],
  "readme": "# minilog\n\nClient & server-side logging with Stream API-backends and counting, timing support\n\n### Why?\n\n- Works in the browser and on the server (< 80 lines)\n- log.debug, log.info, log.warn, log.error\n- Backends - Node: Console, File, Redis\n- Backends - browser: Console, LocalStorage, jQuery.ajax (todo: Engine.io)\n- Pipe to one or more backend streams at the same time\n- Pipes can each have a formatters and filters applied to it\n- Logging can be scoped to a module; enable/disable logging selectively by level or module\n- Support for counting and timing via #event_hashtags (e.g. [hashmonitor](https://speakerdeck.com/u/mjpizz/p/monitor-like-a-boss))\n\n# Example\n\n    // logs can be scoped (\"app\" namespace)\n    var log = require('minilog')('app');\n\n    // pipe to one or more backends\n    require('minilog').pipe(process.stdout);\n\n    log\n      .debug('debug message')\n      .info('info message')\n      .warn('warning')\n      .error('this is an error message');\n\n# Installing\n\n    $ npm install minilog\n\n# Pipes everywhere\n\nminilog is more convention than code. The logger is an eventemitter, and backends are pipes to a writable stream. To log to the console:\n\n    require('minilog').pipe(process.stdout);\n\nTo log into a file:\n\n    require('minilog').pipe(fs.createWriteStream('./temp.log'));\n\nTo log into Redis:\n\n    var client = require('redis').createClient();\n    require('minilog').pipe(\n      new require('minilog').backends.redis({ client: client, key: 'logs'})\n      );\n\nTo log over HTTP via jQuery.ajax:\n\n    require('minilog').pipe(\n      new require('minilog').backends.jquery({ url: 'http://localhost/'})\n      );\n\nYou can pipe to more than one pipe if you want.\n\n## Basic usage and namespaces\n\nminilog works in Node, and in the browser. Basic usage with Node:\n\n    var log = require('minilog')('app');\n\n    require('minilog').pipe(process.stdout);\n\n    log\n      .debug('debug message')\n      .info('info message')\n      .warn('warning')\n      .error('this is an error message');\n\nBasic usage in the browser (via a single exported global ```window.Minilog```:\n\n    <script src=\"dist/minilog.js\"></script>\n    <script>\n    var log = Minilog('myModule');\n\n    Minilog.pipe(Minilog.backends.browser);\n\n    log.info('info message');\n    </script>\n\nThere is a default build included under ```./dist/minilog.js```. It includes a selection of backends. You can also make your own build by running ```node build.js``` which allows you to select which backends to include in the build.\n\n## Configuration overview\n\n- Filters\n- Themes\n- Formatters\n\n## Filtering\n\nFilters can be applied to each pipe individually:\n\n    MiniLog\n      .pipe(process.stdout)\n      .filter(function(name, level) {\n        var ns = {'worker': true, 'http': true},\n            type = {'warn': true, 'error': true};\n        return whitelist[name] && type[level];\n      });\n\n## Filtering - Browser\n\nThe dist/minilog.js file includes additional functionality for enabling/disabling logging in the browser. There are two ways to control logging: via the console, and via the URL.\n\nVia the console:\n\n    Minilog.enable(); // enable all logging\n    Minilog.enable('*.warn'); // only log where level > \"warn\"\n    // all levels on chat and model_foo\n    Minilog.enable('chat,model_foo');\n    // only log where level > \"warn\" for \"chat\" module and\n    // for logging where level > debug for modules starting with \"model\"\n    Minilog.enable('chat.warn,model*.debug');\n\nIf localStorage is available, then these settings will be stored in localStorage so that you don't need to run them after each reload.\n\nVia the URL (applied only when the page is reloaded):\n\n    http://www.example.com/index.html?minilog=\n    http://www.example.com/index.html?minilog=*.warn\n    http://www.example.com/index.html?minilog=chat,model_foo\n    http://www.example.com/index.html?minilog=chat.warn,model*.debug\n\nNote that this functionality is just for the pipe to the browser console. If you have additional loggers (such as sending logs back to the server via AJAX), then you need to use the regular pipe() API to set those up.\n\n## Filtering - Node\n\nThe node_console backend (./backends/node_console.js) comes with a filter that works like the in-browser filter, except it requires that you pass it a value - usually an environment variable:\n\n    var MiniLog = require('minilog'),\n        ConsoleBackend = MiniLog.backends.nodeConsole;\n\n    MiniLog\n      .pipe(ConsoleBackend)\n      .format(ConsoleBackend.formatWithStack)\n      .filter(ConsoleBackend.filterEnv(process.env.MYENV));\n\nExamples:\n\n    $ export MYENV=\"foo.*\" && node whitelist_example.js\n    foo  info whitelist_example.js:14 Hello world\n\nNote that filters are applied to each pipe individually, so if you have two pipes, you need to set the filter on both (or you can use different filters).\n\n## Themes - Node\n\nIn Node, you can do fancy formatting. The node_console backend has several built-in inspired by [logme](https://github.com/vesln/logme). To enable, configure the format() function:\n\n    var Minilog = require('minilog'),\n        consoleBackend = Minilog.backends.nodeConsole;\n    Minilog.pipe(consoleBackend).format(consoleBackend.formatClean);\n\n![screenshot](https://github.com/mixu/minilog/raw/master/test/example/screenshot.png)\n\nHave a look at [./test/examples/themes_example.js](https://github.com/mixu/minilog/blob/master/test/example/themes_example.js) - basically, you pass the formatter to .pipe().format().\n\nThe withStack formatter can print the module name and current line number by examining the stack trace.\n\n## Formatting / templating\n\nEach pipe returns a chainable config object. Formatting can be applied to pipes:\n\n    MiniLog\n      .pipe(process.stdout)\n      .format(function(name, level, args) {\n        return (name ? name.toUpperCase() + ' - ' : '')\n             + (level ? level.toUpperCase() + ' ' : '')\n             + args.join(' ') + '\\n';\n      });\n\nYou can set the default formatter via Minilog.format(fn). You might use this to add extra information - like the date, or associated user etc.\n\n\n## Counting and timing\n\nTODO not done\n\n    log.error('cookie problems #nocookies_for_session'); // use #event for counting\n    log.info('#connected #boot_time=100'); // use #timing=value for timing\n\n## Logging as JSON over a remote connection\n\n## Disabling logging completely via your build system\n\nIf your build system supports this (e.g. onejs --tie minilog=\"...\"), use this replacement to disable logging in production builds:\n\n    function minilog() { return minilog; };\n\n\n\n\nLogging window.onerror (assuming log is a reference to a logger):\n\n    window.onerror = function(message, file, line){\n      log(file+':'+line+' '+message);\n    }\n",
  "readmeFilename": "readme.md",
  "_id": "minilog@0.1.0",
  "_from": "minilog@0.1.0"
}
