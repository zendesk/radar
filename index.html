<!DOCTYPE html>
<html>
  <head>
    <title>radar - High level API and backend for writing web apps that use push messaging</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link type="text/css" rel="stylesheet" href="../assets/css/gh.css"/>
    <link rel="stylesheet" href="assets/css/style.css">
    <link type="text/css" rel="stylesheet" href="assets/css/prettify.css"/>

    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
    <script type="text/javascript" src="assets/js/prettify.js"></script>

  </head>
<body onload="prettyPrint()">
  <div id="wrapper">
    <div id="header">
      <div id="title">

<h1>radar</h1>

<h2>High level API and backend for writing web apps that use push messaging</h2>

<h3>Features</h3>
<ul class="list">
<li><p>more than just pub/sub: a resource-based API for presence, messaging and push notifications via a Javascript client library</p></li>
<li><p>REST API for working with web apps that don&#39;t use Node</p></li>
<li><p>written in Javascript/Node.js, and uses engine.io (the new, lower-level complement to socket.io)</p></li>
<li><p>backend which can utilize to multiple front-facing servers to serve requests.</p></li>
</ul>


      </div>
      <div id="navi">
<ul class="ca-menu">
  <li>
      <a href="https://github.com/zendesk/radar" target="_blank">
          <span class="ca-icon"><i class="icon-heart"></i></span>
          <div class="ca-content">
              <h2 class="ca-main">Watch</h2>
              <h3 class="ca-sub">+1 on GitHub</h3>
          </div>
      </a>
  </li>
  <li>
      <a href="https://github.com/zendesk/radar" target="_blank">
          <span class="ca-icon"><i class="icon-github"></i></span>
          <div class="ca-content">
              <h2 class="ca-main">Fork</h2>
              <h3 class="ca-sub">Full source code on Github</h3>
          </div>
      </a>
  </li>

</ul>



      </div>
    </div>

    <div class="clear"></div>
    <div id="main">
      <div id="content" class="post">
<!-- Content -->
<h2>What is Radar and how is it different from (Socket.io|Sockjs|Faye|Meteor)?</h2>
<p>Radar is built on top of <a href="https://github.com/learnboost/engine.io">Engine.io</a>, the next generation backend for Socket.io. It uses Redis for backend storage, though the assumption is that this is only for storing currently active data.

</p>
<p>Radar basically solves a number of real-world problems that need to be solved, and it reduces the need for specialized backend services by providing good primitive operations.


</p>
<ul class="list">
<li><p>Radar has higher level APIs that cover basic use cases such as presence, persisted message channels. Many push notification frameworks only expose message passing and do not explicitly handle having multiple backend servers, leaving the implementation for their users. Radar provides higher level constructs, so that you are for example:</p>
<ul class="list">
<li>subscribing to notifications about a user going online/offline</li>
<li>subscribing to notifications about changes to a shared variable in a database</li>
<li>sending messages to a channel</li>
</ul>
<p>... rather than just passing messages. More complex systems can be built by combining the Radar API resources.</p>
</li>
<li>REST API for interacting with Radar resources from non-Node web frameworks.</li>
<li>Configurable authentication for resources. You can restrict access based on a token.</li>
<li>Robust recovery. Radar takes care of re-establishing subscriptions in the event of a server error. Other frameworks can recover a connection, but not the application-level subscriptions and state.</li>
<li>Multi-server support via shared Redis instance. Add capacity by adding new server instances behind a load balancer.</li>
<li>Persistence. Messages can be stored (for long-ish terms) in the backend. For example, you might want to be able to send recent messages to new users joining a chat - this can be configured via a policy.</li>
<li>Library, not a framework. Doesn&#39;t require code changes or structural changes beyond responding to the events from the backend.</li>
</ul>
<h2>Installing</h2>
<pre class="prettyprint">npm install radar_client</pre>
<h1>Radar client</h1>
<h2>Basic usage</h2>
<pre class="prettyprint">RadarClient.configure({ ... }).alloc(&#39;example&#39;, function (){
  RadarClient.status(&quot;invite/1234&quot;)
    .on(function(msg) { console.log(msg) })
    .sync();
}).connect();</pre>
<p>&quot;example&quot; is an arbitrary name for your functionality, which is used to determine whether to keep the connection alive or not.

</p>
<p>API calls - see the <a href="rest.html">REST API docs</a> for more details:

</p>
<pre class="prettyprint">curl -k -H &quot;Content-Type: application/json&quot; -X POST \
-d &#39;{&quot;accountName&quot;:&quot;test&quot;,&quot;scope&quot;:&quot;invite/1234&quot;, \
&quot;key&quot;:&quot;greeting&quot;,&quot;value&quot;:&quot;hello&quot;}&#39; https://localhost/radar/status</pre>
<h2>Configuration</h2>
<p>The backend URL needs to be configured before using RadarClient.

</p>
<pre class="prettyprint">RadarClient.configure({
  host: &#39;localhost&#39;,
  port: 8000,
  secure: false,
  userId: 1,
  userType: 2,
  accountName: &#39;test&#39;
});</pre>
<p>The configuration object is passed to the underlying <a href="https://github.com/LearnBoost/engine.io-client">engine.io-client</a>.

</p>
<h2>Connecting via .alloc() / .dealloc()</h2>
<p>The .alloc() and .dealloc() connection API allows multiple independent parts of a web app to use a single persistent connection. This way the Radar client can tell when no-one is using the connection. If a direct connect()/disconnect() API was used, inpendent parts of the app could accidentally disconnect even when the connection is still used elsewhere.

</p>
<ul class="list">
<li><p><code>.alloc(name, callback)</code></p>
<ul class="list">
<li>Ensures that a connection is established, then calls the callback. If the connection is not established, then the call is delayed until connected.</li>
<li>The name can be any string unique to the functionality (e.g. chat, voice etc.)</li>
</ul>
</li>
<li><p><code>.dealloc(name)</code></p>
<ul class="list">
<li>Indicates that the connection is no longer needed by the named functionality.</li>
<li>When no-one needs the connection, issues a disconnect.</li>
</ul>
</li>
</ul>
<p>Unlike a simple counter, alloc() and dealloc() can be safely called multiple times.

</p>
<h2>Accessing resources</h2>
<p>The Radar client API is resource-based. Resources have a type and a name, and support different operations.

</p>
<ul class="list">
<li><code>RadarClient.presence(name)</code>: &quot;whether a user is online and marked as present on this resource&quot;. Presence is tied to the user ID.</li>
<li><code>RadarClient.status(name)</code>: &quot;a hash with subkeys you can subscribe to, such as when a post was last updated&quot;. Status resources exist so that your can receive notifications about a single value changing, for example, when your web backend updates a value.</li>
<li><code>RadarClient.message(name)</code>: &quot;a ordered stream of messages&quot;. Message lists are like chat message streams. They contain messages, and can be configured to store those messages so that new participants can fetch the full history of messages. In the event of a connection loss, any messages sent while disconnected are sent when the connection is re-established.</li>
</ul>
<p>Each of these returns a chainable object specific to that resource + name.

</p>
<p>For example:

</p>
<pre class="prettyprint">RadarClient.presence(name).on(function(message) {
    console.log(message);
  }).set(&#39;online&#39;).sync();</pre>
<h2>Message handlers</h2>
<p>All resources accept message handlers. Message handlers are triggered when a message relevant to the resource is received. You have three choices:

</p>
<ul class="list">
<li><code>.on(callback)</code>: attach a handler permanently until explicitly removed</li>
<li><code>.once(callback)</code>: attach a handler that is removed after it is triggered once</li>
<li><code>.when(callback)</code>: attach a handler that is only removed if the return value from the handler is true. Useful for waiting for a specific message.</li>
</ul>
<p>Callbacks accept one argument, which is the message returned from the backend.

</p>
<h2>Operations</h2>
<p>Each resource type has its own set of operations.

</p>
<h3>Operation acknowledgements</h3>
<p>Many functions take an optional [ack] callback function argument as their last parameter. If the ack callback is specified, the client requests an acknowledgement (ACK) from the server, and runs the callback when the ACK is received. This is useful for tests and when you want to be sure that an operation has completed before going to the next one.

</p>
<h2>Presence resources</h2>
<p>These are binary (e.g. online and offline). Presence is tied to the user id, and it can be set to &quot;offline&quot; either explicitly, or if the user&#39;s TCP connection is lost (there is a grace period up to 30 seconds).

</p>
<h3>Presence API methods .presence(&quot;scope&quot;).*</h3>
<ul class="list">
<li><p><code>.get(callback)</code></p>
<ul class="list">
<li>Immediately retrieves the presence resource content and returns it.</li>
<li><p>callback(message): message is a JSON object, which looks like this:</p>
<p>{
  &quot;op&quot;: &quot;get&quot;
  &quot;value&quot;: { &quot;123&quot;: 0 }
}</p>
</li>
</ul>
</li>
</ul>
<p>Here, 123 is the user ID, and 0 is the user&#39;s type (0 = enduser, 2 = agent, 4 = admin).

</p>
<p>If the user is offline, they will not be included in the result.

</p>
<ul class="list">
<li><code>.set(&#39;online&#39;, [ack])</code> / <code>.set(&#39;offline&#39;, [ack])</code><ul class="list">
<li>Sets presence</li>
</ul>
</li>
<li><code>.subscribe([ack])</code><ul class="list">
<li>Subscribes to notifications on the current presence resource (which includes the current user and other users that act on that presence resource)</li>
</ul>
</li>
<li><code>.unsubscribe([ack])</code><ul class="list">
<li>Removes a subscription</li>
</ul>
</li>
</ul>
<h2>Status resources</h2>
<p>Push notifications about changes to a variable.

</p>
<p>Status resources can have multiple values (e.g. browser, phone, unavailable). Status is per-user, but it never expires by itself and is not tied to user presence.

</p>
<h3>Status API methods .status(&quot;scope&quot;).*</h3>
<ul class="list">
<li><p><code>.get(callback)</code></p>
<ul class="list">
<li>Immediately retrieves the status resource content and returns it.</li>
<li><p>callback(message): message is a JSON object, which looks like this:</p>
<p>{
  &quot;op&quot;: &quot;get&quot;
  &quot;value&quot;: { &quot;123&quot;: &quot;foo&quot; }
}</p>
</li>
</ul>
</li>
</ul>
<p>Here, 123 is the user ID, and &quot;foo&quot; is the value set by calling status(&#39;abc&#39;).set(&#39;foo&#39;);

</p>
<p>You can set the value to an arbitrary JSON object: <code>.status(&#39;voice/status&#39;).set({ hello: &quot;world&quot; });</code>

</p>
<ul class="list">
<li><code>.set(&#39;foo&#39;, [ack])</code><ul class="list">
<li>Sets status</li>
</ul>
</li>
<li><code>.subscribe([ack])</code><ul class="list">
<li>Subscribes to notifications</li>
</ul>
</li>
<li><code>.unsubscribe([ack])</code><ul class="list">
<li>Removes a subscription</li>
</ul>
</li>
</ul>
<h2>Message list resources</h2>
<p>Message streams about a topic.

</p>
<p>Message lists contain ordered information that can be appended to, and can be synchronized. In the event of a connection loss, any messages sent while disconnected are sent when the connection is re-established.

</p>
<h3>Message list API methods</h3>
<p>Note: the API here conforms to the Drone API so that we can transition from Drone to Radar_client fairly easily.

</p>
<ul class="list">
<li><code>.subscribe(&#39;channel&#39;)</code></li>
<li><code>.unsubscribe(&#39;channel&#39;)</code></li>
<li><code>.sync(&#39;channel&#39;)</code></li>
<li><code>.publish(&#39;channel&#39;, message)</code></li>
</ul>
<p>By default, message list resources are not persistent - e.g. messages will be sent to subscribers, but the message history is not accessible. You can configure message persistence on a per-resource-type basis in the server - see the server configuration for details.


</p>
<h2>Client states</h2>
<p>There are a few states that the client UI should handle gracefully:

</p>
<ul class="list">
<li>&quot;connected&quot; AKA &quot;ready&quot;: This should be a once() callback, and set up the basic UI.</li>
<li>&quot;disconnected&quot;: If this state occurs, then the UI should be set in a state that 1) makes it clear that communication is currently not possible and 2) allows the user to perform a reconnection. For example, gray out all users in a chat and show a yellow notification stating &quot;reconnecting&quot;.</li>
<li>&quot;reconnecting&quot;: the notification should change to show that a reconnection is in progress or is pending:
reconnecting(in_seconds) events should occur.</li>
<li>&quot;reconnected&quot;: the notification should change to show that the user is now connected again.</li>
<li>&quot;unavailable&quot;: If this state occurs, then the UI should show a message that the connection could not be established.</li>
</ul>
<h1>REST API</h1>
<p>Read the <a href="rest.html">REST API docs</a> for the details.

</p>
<h1>Radar server</h1>
<h2>Starting the sample server</h2>
<pre class="prettyprint">git clone ...
npm install
npm start</pre>
<p><code>npm start</code> starts the example server.

</p>
<h2>Installing the Radar server</h2>
<pre class="prettyprint">npm install --save radar</pre>
<h2>Configuration</h2>
<p> Radar attaches to a regular Node http server. The API and the server can be attached separately: if you don&#39;t want the REST API, you can leave it out or switch it with a custom API.

</p>
<pre class="prettyprint">var http = require(&#39;http&#39;),
    Radar = require(&#39;radar&#39;).server,
    Api = require(&#39;radar&#39;).api,
    httpServer = http.createServer(function(req, res) {
      res.end(&#39;Nothing here.&#39;);
    });

// Radar API
Api.attach(httpServer);

// Radar server
Radar.attach(httpServer, { redis_host: &#39;localhost&#39;, redis_port: 6379 });

httpServer.listen(8000);</pre>
<p>The server accepts two configurable options:

</p>
<ul class="list">
<li><code>redis_host</code> and <code>redis_port</code>: the hostname and port where the Redis server is running</li>
</ul>
<h2>Authentication and persistence</h2>
<p>Authentication and persistence are configured on a resource-type basis.

</p>
<p>The resource type is detected by checking resource names against a regular expression in the server.

</p>
<p>Resources are given names based on 1) their type and 2) the accountName associated with the resource. For example:

</p>
<ul class="list">
<li>status:/dev/foo/bar represents a status resource, for the account &quot;dev&quot;, named &quot;foo/bar&quot;</li>
<li>message:/test/chat/1 represents a message list resource, for the account &quot;test&quot;, named &quot;chat/1&quot;</li>
<li>presence:/test/chat/1 represents a presence resource, for the account &quot;test&quot;, named &quot;chat/1&quot;</li>
</ul>
<p>Policies are specified by definingn and registering resource types on the server. For example:


</p>
<pre class="prettyprint">var http = require(&#39;http&#39;),
    Radar = require(&#39;radar&#39;).server,
    Type = require(&#39;radar&#39;).core.Type;

var types = require(&#39;./my_types.js&#39;);

Object.keys(types).forEach(function(name) {
  Type.register(name, types[name]);
});
// ... and then later
server = http.createServer(function() { ... });
Radar.attach(server, configuration);</pre>
<p>Persistence policies can be applied to message and status resources.

</p>
<pre class="prettyprint">chat_messages: {
  expr: new RegExp(&#39;^message:/.+/chat/.+$&#39;),
  type: &#39;message&#39;,
  policy: { cache: true },
  auth: function(message) {
    //...
  }
}</pre>
<p>Policy options:

</p>
<ul class="list">
<li><code>cache</code>: true | false</li>
<li><code>maxAgeSeconds</code>: number - applicable to both message list and status resources. With message lists, messages older than maxAgeSeconds are pruned on read. With status resources, status resources unused (not updated) for maxAgeSeconds will be removed.</li>
<li><code>maxCount</code>: number - only applicable to message list resources</li>
</ul>
<h2>Deployment</h2>
<p>Radar can be deployed as a single instance directly serving requests, or with multiple instances of the Radar server behind a load balancer.

</p>
<p>If a load balancer is used, then servers behind the load balancer can be restarted safely, and the clients will recover their connections as long as at least one Radar server remains available.

</p>
<p>The load balancer must use source IP sticky sessions. Radar itself does not need sticky sessions, as it can recover the correct state from Redis and the client, but Engine.io does (due to the way handshakes are done). Radar clients will recover from a server crash, as long as the load balancer points them to a different server.

</p>
<p>Normal Redis replication can be used to scale beyond a single Redis backend (or, the servers can be sharded e.g. by account, each with their own backend).

</p>
<h2>Copyright and License</h2>
<p>Radar is Copyright 2012, Zendesk Inc.

</p>
<p>Licensed under the Apache License Version 2.0, <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>

</p>

<!-- end content -->
      </div>
    </div>

    <div class="clear">
    </div>

    <div id="footer">
    </div>
  </div>
</body>
</html>
